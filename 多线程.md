# 多线程

锁的类型:

1. 乐观锁（乐观地认为只有一个线程）
2. 悲观锁（Synchronize）
3. 自旋锁
4. 读写锁
5. 分段锁（Long Adder，Concurrent Hash Map）<font color="red">连老师</font>

```lock.newCondition()```给锁分等待队列。

## Volatile 线程可见性

修饰简单对象（值类型）

不要修饰引用对象，引用对象的成员变量改变是不受控制的。

## synchronize

锁升级 : 没有锁->偏向锁->自旋锁->重量级锁(OS)

## Reentrant Lock 可重入锁

可以代替synchronize

1. __必须手动unlock__
2. 可以进行```tryLock```，可以指定try的时间。返回值
3. 可以进行```lockInterruptibly```，会被```Thread.interrupt()```打断，触发```InterruptedException```异常。
   <font color="red">注意：</font>即时使用```lock()```，如果线程中有```Thread.sleep```的话，也会被打断并触发异常。
4. 可以指定公平策略。true/false

## Count Down Latch 计数门栓

```latch.countDown()```是原子性的。

```latch.await();```会阻塞等待计数器归零。

## Cyclic Barrier 栅栏

```CyclicBarrier(int parties, Runnable barrierAction)```触发量、触发事件

线程通过```barrier.await()```阻塞加入栅栏队列。

在达到触发量后，会解除阻塞继续执行，并且：方法返回线程到达栅栏的序号。

**可以用在流转批**

## Phaser 阶段性栅栏

通过```xxxClass extends Phaser```继承实现自定义阶段。

通过```phaser.bulkRegister(5);```规定线程参与人数。

重写```boolean onAdvance(int phase, int registeredParties)```控制流程。

phase：流程index。registeredParties 当前流程注册的线程数。

```phaser.arriveAndAwaitAdvance();```注册，并进入下一个流程，等待流程触发。

```arriveAndDeregister```声明不再参与流程，流程触发限定数会--；

```register```通知、声明不再参与下一个流程，流程触发限定数会在下一次--；

##  Reentrant Read Write Lock 读写锁

分为读锁和写锁。

读锁：共享，不互斥。如果所有的线程都是读访问，即可以认为不加锁。

写锁：不共享，互斥。如果读写操作交替发生，可以认为是**Synchronize**。

## Semaphore 信号

```new Semaphore(int permits, boolean fair)```

permits：允许同时运行的线程数，fair：是否公平。

使用```semaphore.acquire();```阻塞等待信号触发。

使用```semaphore.release();```声明线程数释放信号。释放后可重新阻塞。

可以指定时间。

## Exchanger 交换器

通过```T newValue=exchanger.exchange(oldValue);```阻塞并获取交换后的变量

**可以用在游戏装备交换场景**

## LockSupport

两个主要方法：```park()和unpark(thread)```。

unpark可以解除一次park()，无论先后。

对于<font color="orange">某一个</font>线程的停止和唤醒。

## Notify（synchronize）

__不释放锁__

```lock.notify();```后必须释放锁，才能解除```lock.wait();```的阻塞状态。